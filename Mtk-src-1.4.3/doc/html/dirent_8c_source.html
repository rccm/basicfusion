<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MISR Toolkit: FileQuery/src/dirent.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_e0d32e6f47aec1a3b56c566cc297c9ae.html">FileQuery</a>      </li>
      <li><a class="el" href="dir_cd2e84d73c739fa13a8e3bc0b242933c.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>dirent.c</h1>  </div>
</div>
<div class="contents">
<a href="dirent_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * @(#)msd_dir.c 1.4 87/11/06   Public Domain.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  A public domain implementation of BSD directory routines for</span>
<a name="l00005"></a>00005 <span class="comment"> *  MS-DOS.  Written by Michael Rendell ({uunet,utai}michael@garfield),</span>
<a name="l00006"></a>00006 <span class="comment"> *  August 1897</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *  Modified by Ian Stewartson, Data Logic (istewart@datlog.co.uk).</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> *  Updates:  1.  To support OS/2 1.x</span>
<a name="l00011"></a>00011 <span class="comment"> *        2.  To support HPFS long filenames</span>
<a name="l00012"></a>00012 <span class="comment"> *        3.  To support OS/2 2.x</span>
<a name="l00013"></a>00013 <span class="comment"> *        4.  To support TurboC</span>
<a name="l00014"></a>00014 <span class="comment"> *        5.  To support Windows NT</span>
<a name="l00015"></a>00015 <span class="comment"> */</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;malloc.h&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;limits.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="dirent__win32_8h.html">dirent_win32.h</a>&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 
<a name="l00031"></a><a class="code" href="dirent_8c.html#ac7bef5d85e3dcd73eef56ad39ffc84a9">00031</a> <span class="preprocessor">#define WIN32_LEAN_AND_MEAN</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a><a class="code" href="dirent_8c.html#af1ea84138ee9d1883d800ed973ac037c">00034</a> <span class="preprocessor">#define FILE_NAME_E     cFileName</span>
<a name="l00035"></a><a class="code" href="dirent_8c.html#aa81b55174259dfa0ce5e16f528684ad7">00035</a> <span class="preprocessor"></span><span class="preprocessor">#define OS_CloseFH(a)       FindClose (a)</span>
<a name="l00036"></a><a class="code" href="dirent_8c.html#a6859ae06fe7b6132735490fb96ee181a">00036</a> <span class="preprocessor"></span><span class="preprocessor">#define FIND_BUFFER     WIN32_FIND_DATA</span>
<a name="l00037"></a><a class="code" href="dirent_8c.html#afa1ceb2cc63088f6af764bf3468ab353">00037</a> <span class="preprocessor"></span><span class="preprocessor">#define DISABLE_HARD_ERRORS SetErrorMode (0)</span>
<a name="l00038"></a><a class="code" href="dirent_8c.html#a492fb11c68161f5d96c35bba9ffda9ef">00038</a> <span class="preprocessor"></span><span class="preprocessor">#define ENABLE_HARD_ERRORS  SetErrorMode (SEM_FAILCRITICALERRORS | \</span>
<a name="l00039"></a>00039 <span class="preprocessor">                          SEM_NOOPENFILEERRORBOX);</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a><a class="code" href="dirent_8c.html#acd448749c60ad15581e658db10c4b6a2">00041</a> <span class="preprocessor">#  define ERROR_EMPTY_DIR   ERROR_FILE_NOT_FOUND</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a><a class="code" href="dirent_8c.html#ae456bc7dfd6c3d54bccef2e234ecae7a">00043</a> <span class="preprocessor">#  define ATTRIBUTES        (_A_SUBDIR | _A_HIDDEN | _A_SYSTEM | \</span>
<a name="l00044"></a>00044 <span class="preprocessor">                 _A_NORMAL | _A_RDONLY | _A_ARCH)</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="comment">/*</span>
<a name="l00047"></a>00047 <span class="comment"> * missing ??</span>
<a name="l00048"></a>00048 <span class="comment"> */</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#ifndef ENOTDIR</span>
<a name="l00051"></a><a class="code" href="dirent_8c.html#a9262fb92f7ef662d0bdd577912a5b101">00051</a> <span class="preprocessor"></span><span class="preprocessor">#  define ENOTDIR   120 </span><span class="comment">/* Not a directory          */</span>
<a name="l00052"></a>00052 <span class="preprocessor">#endif</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="preprocessor">#ifndef S_IFMT</span>
<a name="l00055"></a><a class="code" href="dirent_8c.html#ab5bee51e9ee68b83ab11d4b340f7200b">00055</a> <span class="preprocessor"></span><span class="preprocessor">#  define   S_IFMT  0xf000  </span><span class="comment">/* type of file             */</span>
<a name="l00056"></a>00056 <span class="preprocessor">#endif</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058 <span class="preprocessor">#ifndef S_ISDIR</span>
<a name="l00059"></a><a class="code" href="dirent_8c.html#a70b64ed67c0ab484b4ba09487da34e91">00059</a> <span class="preprocessor"></span><span class="preprocessor">#  define S_ISDIR(m)    ((((m) &amp; S_IFMT) == S_IFDIR))</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span>
<a name="l00062"></a>00062 <span class="comment">/*</span>
<a name="l00063"></a>00063 <span class="comment"> * Internals</span>
<a name="l00064"></a>00064 <span class="comment"> */</span>
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="dirent_8c.html#aac91efe35e45c3705d071d003e3c26a1">00066</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct__dircontents.html">_dircontents</a> <a class="code" href="struct__dircontents.html">DIRCONT</a>;
<a name="l00067"></a>00067 <span class="keyword">static</span> <span class="keywordtype">void</span>         <a class="code" href="dirent_8c.html#af3dc7f15b289bb28f8a54ad892cd16a0">free_dircontents</a> (<a class="code" href="struct__dircontents.html">DIRCONT</a> *);
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/*</span>
<a name="l00070"></a>00070 <span class="comment"> * Open the directory stream</span>
<a name="l00071"></a>00071 <span class="comment"> */</span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <a class="code" href="struct__dirdesc.html">DIR</a> *
<a name="l00074"></a><a class="code" href="dirent_8c.html#ad251c79860d7d65fc68173141d1a3b21">00074</a> <a class="code" href="dirent_8c.html#ad251c79860d7d65fc68173141d1a3b21">opendir</a> (<a class="code" href="hproto__fortran_8h.html#aca6d1e2e1c007827670e77fee2f6fae3">name</a>)
<a name="l00075"></a>00075     <a class="code" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <span class="keywordtype">char</span>  *<a class="code" href="hproto__fortran_8h.html#aca6d1e2e1c007827670e77fee2f6fae3">name</a>;
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077     <span class="keyword">struct </span>stat     statb;
<a name="l00078"></a>00078     <a class="code" href="struct__dirdesc.html">DIR</a>         *dirp;
<a name="l00079"></a>00079     <span class="keywordtype">char</span>        *last;
<a name="l00080"></a>00080     <a class="code" href="struct__dircontents.html">DIRCONT</a>     *dp;
<a name="l00081"></a>00081     <span class="keywordtype">char</span>        *nbuf;
<a name="l00082"></a>00082     <span class="keywordtype">int</span>         <a class="code" href="hproto__fortran_8h.html#a57c2695a854c02fec7173c4c067b6785">len</a> = strlen (name);
<a name="l00083"></a>00083     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   rc;
<a name="l00084"></a>00084     <a class="code" href="dirent_8c.html#a6859ae06fe7b6132735490fb96ee181a">FIND_BUFFER</a>     dtabuf;
<a name="l00085"></a>00085     HANDLE      d_handle;
<a name="l00086"></a>00086     <span class="keywordtype">bool</span>        HPFS = FALSE;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <span class="keywordflow">if</span> (!len)
<a name="l00089"></a>00089     {
<a name="l00090"></a>00090     errno = ENOTDIR;
<a name="l00091"></a>00091     <span class="keywordflow">return</span> (<a class="code" href="struct__dirdesc.html">DIR</a> *)NULL;
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094     <span class="keywordflow">if</span> ((nbuf = malloc (len + 5)) == (<span class="keywordtype">char</span> *)NULL)
<a name="l00095"></a>00095     <span class="keywordflow">return</span> (<a class="code" href="struct__dirdesc.html">DIR</a> *) NULL;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     strcpy (nbuf, name);
<a name="l00098"></a>00098     last = &amp;nbuf[len - 1];
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">/* Ok, DOS is very picky about its directory names.  The following are</span>
<a name="l00101"></a>00101 <span class="comment"> * valid.</span>
<a name="l00102"></a>00102 <span class="comment"> *</span>
<a name="l00103"></a>00103 <span class="comment"> *  c:/</span>
<a name="l00104"></a>00104 <span class="comment"> *  c:.</span>
<a name="l00105"></a>00105 <span class="comment"> *  c:name/name1</span>
<a name="l00106"></a>00106 <span class="comment"> *</span>
<a name="l00107"></a>00107 <span class="comment"> *  c:name/ is not valid</span>
<a name="l00108"></a>00108 <span class="comment"> */</span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     <span class="keywordflow">if</span> (((*last == <span class="charliteral">&#39;\\&#39;</span>) || (*last == <span class="charliteral">&#39;/&#39;</span>)) &amp;&amp; (len &gt; 1) &amp;&amp;
<a name="l00111"></a>00111     (!((len == 3) &amp;&amp; (name[1] == <span class="charliteral">&#39;:&#39;</span>))))
<a name="l00112"></a>00112     *(last--) = 0;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="comment">/* Check its a directory */</span>
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     DISABLE_HARD_ERRORS;
<a name="l00117"></a>00117     rc = stat (nbuf, &amp;statb);
<a name="l00118"></a>00118     ENABLE_HARD_ERRORS;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     <span class="keywordflow">if</span> (rc)
<a name="l00121"></a>00121     {
<a name="l00122"></a>00122     free (nbuf);
<a name="l00123"></a>00123     <span class="keywordflow">return</span> (<a class="code" href="struct__dirdesc.html">DIR</a> *) NULL;
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="keywordflow">if</span> (!<a class="code" href="dirent_8c.html#a70b64ed67c0ab484b4ba09487da34e91">S_ISDIR</a> (statb.st_mode))
<a name="l00127"></a>00127     {
<a name="l00128"></a>00128     free (nbuf);
<a name="l00129"></a>00129     errno = ENOTDIR;
<a name="l00130"></a>00130     <span class="keywordflow">return</span> (<a class="code" href="struct__dirdesc.html">DIR</a> *)NULL;
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     <span class="keywordflow">if</span> ((dirp = (<a class="code" href="struct__dirdesc.html">DIR</a> *) malloc (<span class="keyword">sizeof</span> (<a class="code" href="struct__dirdesc.html">DIR</a>))) == (<a class="code" href="struct__dirdesc.html">DIR</a> *) NULL)
<a name="l00134"></a>00134     {
<a name="l00135"></a>00135     free (nbuf);
<a name="l00136"></a>00136     <span class="keywordflow">return</span> (<a class="code" href="struct__dirdesc.html">DIR</a> *) NULL;
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="comment">/* Set up to find everything */</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     <span class="keywordflow">if</span> ((*last != <span class="charliteral">&#39;\\&#39;</span>) &amp;&amp; (*last != <span class="charliteral">&#39;/&#39;</span>))
<a name="l00142"></a>00142     strcat (last, <span class="stringliteral">&quot;/&quot;</span>);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     strcat (last, <span class="stringliteral">&quot;*.*&quot;</span>);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="comment">/* Find the file system type */</span>
<a name="l00147"></a>00147 
<a name="l00148"></a>00148     HPFS = <a class="code" href="dirent_8c.html#a50fb9328e8a660db213e104750aa3fb6">IsHPFSFileSystem</a> (nbuf);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     dirp-&gt;dd_loc      = 0;
<a name="l00151"></a>00151     dirp-&gt;dd_cp       = (<a class="code" href="struct__dircontents.html">DIRCONT</a> *) NULL;
<a name="l00152"></a>00152     dirp-&gt;<a class="code" href="struct__dirdesc.html#a2cafa298385ba4250b2a55ccd50c7165">dd_contents</a> = (<a class="code" href="struct__dircontents.html">DIRCONT</a> *) NULL;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     DISABLE_HARD_ERRORS;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     d_handle = FindFirstFile (nbuf, &amp;dtabuf);
<a name="l00157"></a>00157     rc = (d_handle == INVALID_HANDLE_VALUE) ? GetLastError () : 0;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159     ENABLE_HARD_ERRORS;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">/* Check for errors */</span>
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="keywordflow">if</span> (rc)
<a name="l00164"></a>00164     {
<a name="l00165"></a>00165     free (nbuf);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment">/* Empty directory */</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="preprocessor">#if defined (ERROR_EMPTY_DIR)</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (rc == <a class="code" href="dirent_8c.html#acd448749c60ad15581e658db10c4b6a2">ERROR_EMPTY_DIR</a>)
<a name="l00171"></a>00171         <span class="keywordflow">return</span> dirp;
<a name="l00172"></a>00172 <span class="preprocessor">#endif</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span>
<a name="l00174"></a>00174     free (dirp);
<a name="l00175"></a>00175     <span class="keywordflow">return</span> (<a class="code" href="struct__dirdesc.html">DIR</a> *) NULL;
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="comment">/* Process the directory */</span>
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <span class="keywordflow">do</span>
<a name="l00181"></a>00181     {
<a name="l00182"></a>00182     <span class="keywordflow">if</span> (((dp = (<a class="code" href="struct__dircontents.html">DIRCONT</a> *) malloc (<span class="keyword">sizeof</span> (<a class="code" href="struct__dircontents.html">DIRCONT</a>))) == (<a class="code" href="struct__dircontents.html">DIRCONT</a> *)NULL) ||
<a name="l00183"></a>00183         ((dp-&gt;<a class="code" href="struct__dircontents.html#a20036d14ba44309f1416cc07e6d92506">_d_entry</a> = strdup (dtabuf.FILE_NAME_E)) == (<span class="keywordtype">char</span> *) NULL))
<a name="l00184"></a>00184     {
<a name="l00185"></a>00185         <span class="keywordflow">if</span> (dp-&gt;<a class="code" href="struct__dircontents.html#a20036d14ba44309f1416cc07e6d92506">_d_entry</a> != (<span class="keywordtype">char</span> *)NULL)
<a name="l00186"></a>00186         free ((<span class="keywordtype">char</span> *)dp);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         free (nbuf);
<a name="l00189"></a>00189         <a class="code" href="dirent_8c.html#af3dc7f15b289bb28f8a54ad892cd16a0">free_dircontents</a> (dirp-&gt;dd_contents);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         <a class="code" href="dirent_8c.html#aa81b55174259dfa0ce5e16f528684ad7">OS_CloseFH</a> (d_handle);
<a name="l00192"></a>00192         <span class="keywordflow">return</span> (<a class="code" href="struct__dirdesc.html">DIR</a> *) NULL;
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     <span class="keywordflow">if</span> (!HPFS)
<a name="l00196"></a>00196         strlwr (dp-&gt;<a class="code" href="struct__dircontents.html#a20036d14ba44309f1416cc07e6d92506">_d_entry</a>);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     <span class="keywordflow">if</span> (dirp-&gt;dd_contents != (<a class="code" href="struct__dircontents.html">DIRCONT</a> *) NULL)
<a name="l00199"></a>00199         dirp-&gt;dd_cp = dirp-&gt;dd_cp-&gt;_d_next = dp;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="keywordflow">else</span>
<a name="l00202"></a>00202         dirp-&gt;dd_contents = dirp-&gt;dd_cp = dp;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     dp-&gt;<a class="code" href="struct__dircontents.html#a44352d9b3cc67c7d30c4f365a0c8100c">_d_next</a> = (<a class="code" href="struct__dircontents.html">DIRCONT</a> *) NULL;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     } <span class="keywordflow">while</span> (FindNextFile (d_handle, &amp;dtabuf));
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     dirp-&gt;dd_cp = dirp-&gt;dd_contents;
<a name="l00209"></a>00209     free (nbuf);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <a class="code" href="dirent_8c.html#aa81b55174259dfa0ce5e16f528684ad7">OS_CloseFH</a> (d_handle);
<a name="l00212"></a>00212     <span class="keywordflow">return</span> dirp;
<a name="l00213"></a>00213 }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="comment">/*</span>
<a name="l00217"></a>00217 <span class="comment"> * Close the directory stream</span>
<a name="l00218"></a>00218 <span class="comment"> */</span>
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 <span class="keywordtype">int</span>
<a name="l00221"></a><a class="code" href="dirent_8c.html#aaeac2b41e8c2c3a5f91c9bd511a8c0a6">00221</a> <a class="code" href="dirent_8c.html#aaeac2b41e8c2c3a5f91c9bd511a8c0a6">closedir</a> (dirp)
<a name="l00222"></a>00222     <a class="code" href="struct__dirdesc.html">DIR</a> *dirp;
<a name="l00223"></a>00223 {
<a name="l00224"></a>00224     <span class="keywordflow">if</span> (dirp != (<a class="code" href="struct__dirdesc.html">DIR</a> *)NULL)
<a name="l00225"></a>00225     {
<a name="l00226"></a>00226     <a class="code" href="dirent_8c.html#af3dc7f15b289bb28f8a54ad892cd16a0">free_dircontents</a> (dirp-&gt;dd_contents);
<a name="l00227"></a>00227     free ((<span class="keywordtype">char</span> *)dirp);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     <span class="keywordflow">return</span> 0;
<a name="l00231"></a>00231 }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="comment">/*</span>
<a name="l00234"></a>00234 <span class="comment"> * Read the next record from the stream</span>
<a name="l00235"></a>00235 <span class="comment"> */</span>
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="keyword">struct </span><a class="code" href="structdirent.html">dirent</a> *
<a name="l00238"></a><a class="code" href="dirent_8c.html#a58257faf8b13b3f14558613c632b2373">00238</a> <a class="code" href="dirent_8c.html#a58257faf8b13b3f14558613c632b2373">readdir</a> (dirp)
<a name="l00239"></a>00239     <a class="code" href="struct__dirdesc.html">DIR</a> *dirp;
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241     <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdirent.html">dirent</a>    dp;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     <span class="keywordflow">if</span> ((dirp == (<a class="code" href="struct__dirdesc.html">DIR</a> *)NULL) || (dirp-&gt;dd_cp == (<a class="code" href="struct__dircontents.html">DIRCONT</a> *) NULL))
<a name="l00244"></a>00244     <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structdirent.html">dirent</a> *) NULL;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     dp.<a class="code" href="structdirent.html#affe13457fe33b592a6f4c0606aade8a4">d_reclen</a> = strlen (strcpy (dp.<a class="code" href="structdirent.html#ad2e718a8e07b81e1aa9c4a95a25924d6">d_name</a>, dirp-&gt;dd_cp-&gt;_d_entry));
<a name="l00247"></a>00247     dp.<a class="code" href="structdirent.html#af812e4ed54eeb48e843efa6fb9a5465f">d_off</a>    = dirp-&gt;dd_loc * 32;
<a name="l00248"></a>00248     dp.<a class="code" href="structdirent.html#aaea0878aa0629630d94e180f5dbc22c5">d_ino</a>    = (ino_t)++dirp-&gt;dd_loc;
<a name="l00249"></a>00249     dirp-&gt;dd_cp = dirp-&gt;dd_cp-&gt;_d_next;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="keywordflow">return</span> &amp;dp;
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="comment">/*</span>
<a name="l00255"></a>00255 <span class="comment"> * Restart the directory stream</span>
<a name="l00256"></a>00256 <span class="comment"> */</span>
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="keywordtype">void</span>
<a name="l00259"></a><a class="code" href="dirent_8c.html#ad4fcb58b9194b1a3c1699654de963719">00259</a> <a class="code" href="dirent_8c.html#ad4fcb58b9194b1a3c1699654de963719">rewinddir</a> (dirp)
<a name="l00260"></a>00260     <a class="code" href="struct__dirdesc.html">DIR</a> *dirp;
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262     <a class="code" href="dirent_8c.html#a36732b23b818c6a5285c51e6c2d09626">seekdir</a> (dirp, (off_t)0);
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="comment">/*</span>
<a name="l00266"></a>00266 <span class="comment"> * Move to a know position in the stream</span>
<a name="l00267"></a>00267 <span class="comment"> */</span>
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keywordtype">void</span>
<a name="l00270"></a><a class="code" href="dirent_8c.html#a36732b23b818c6a5285c51e6c2d09626">00270</a> <a class="code" href="dirent_8c.html#a36732b23b818c6a5285c51e6c2d09626">seekdir</a> (dirp, off)
<a name="l00271"></a>00271     <a class="code" href="struct__dirdesc.html">DIR</a> *dirp;
<a name="l00272"></a>00272     off_t off;
<a name="l00273"></a>00273 {
<a name="l00274"></a>00274     <span class="keywordtype">long</span>    i = off;
<a name="l00275"></a>00275     <a class="code" href="struct__dircontents.html">DIRCONT</a> *dp;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     <span class="keywordflow">if</span> ((dirp == (<a class="code" href="struct__dirdesc.html">DIR</a> *)NULL) || (off &lt; 0L))
<a name="l00278"></a>00278     <span class="keywordflow">return</span>;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     <span class="keywordflow">for</span> (dp = dirp-&gt;dd_contents; (--i &gt;= 0) &amp;&amp; (dp != (<a class="code" href="struct__dircontents.html">DIRCONT</a> *)NULL);
<a name="l00281"></a>00281      dp = dp-&gt;<a class="code" href="struct__dircontents.html#a44352d9b3cc67c7d30c4f365a0c8100c">_d_next</a>)
<a name="l00282"></a>00282     ;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     dirp-&gt;dd_loc = off - (i + 1);
<a name="l00285"></a>00285     dirp-&gt;dd_cp = dp;
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="comment">/*</span>
<a name="l00289"></a>00289 <span class="comment"> * Get the current position</span>
<a name="l00290"></a>00290 <span class="comment"> */</span>
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 off_t
<a name="l00293"></a><a class="code" href="dirent_8c.html#a8bfb15f95d2cc7d37bdec605ceb343f1">00293</a> <a class="code" href="dirent_8c.html#a8bfb15f95d2cc7d37bdec605ceb343f1">telldir</a>(dirp)
<a name="l00294"></a>00294     <a class="code" href="struct__dirdesc.html">DIR</a> *dirp;
<a name="l00295"></a>00295 {
<a name="l00296"></a>00296     <span class="keywordflow">return</span> (dirp == (<a class="code" href="struct__dirdesc.html">DIR</a> *)NULL) ? (off_t) -1 : dirp-&gt;dd_loc;
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="comment">/*</span>
<a name="l00300"></a>00300 <span class="comment"> * Release the internal structure</span>
<a name="l00301"></a>00301 <span class="comment"> */</span>
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00304"></a><a class="code" href="dirent_8c.html#af3dc7f15b289bb28f8a54ad892cd16a0">00304</a> <a class="code" href="dirent_8c.html#af3dc7f15b289bb28f8a54ad892cd16a0">free_dircontents</a> (dp)
<a name="l00305"></a>00305     <a class="code" href="struct__dircontents.html">DIRCONT</a> *dp;
<a name="l00306"></a>00306 {
<a name="l00307"></a>00307     <a class="code" href="struct__dircontents.html">DIRCONT</a> *odp;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309     <span class="keywordflow">while</span> ((odp = dp) != (<a class="code" href="struct__dircontents.html">DIRCONT</a> *)NULL)
<a name="l00310"></a>00310     {
<a name="l00311"></a>00311     <span class="keywordflow">if</span> (dp-&gt;_d_entry != (<span class="keywordtype">char</span> *)NULL)
<a name="l00312"></a>00312         free (dp-&gt;_d_entry);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     dp = dp-&gt;_d_next;
<a name="l00315"></a>00315     free ((<span class="keywordtype">char</span> *)odp);
<a name="l00316"></a>00316     }
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="comment">/*</span>
<a name="l00321"></a>00321 <span class="comment"> * Windows NT version</span>
<a name="l00322"></a>00322 <span class="comment"> */</span>
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="keywordtype">bool</span>
<a name="l00325"></a><a class="code" href="dirent_8c.html#a50fb9328e8a660db213e104750aa3fb6">00325</a> <a class="code" href="dirent_8c.html#a50fb9328e8a660db213e104750aa3fb6">IsHPFSFileSystem</a> (directory)
<a name="l00326"></a>00326     char *directory;
<a name="l00327"></a>00327 {
<a name="l00328"></a>00328     <span class="keywordtype">char</span>        bName[4];
<a name="l00329"></a>00329     DWORD       <a class="code" href="hproto__fortran_8h.html#a4b409aef6b3fc7e399280ec9866c32dc">flags</a>;
<a name="l00330"></a>00330     DWORD       maxname;
<a name="l00331"></a>00331     BOOL        rc;
<a name="l00332"></a>00332     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    nDrive;
<a name="l00333"></a>00333     <span class="keywordtype">char</span>        szCurDir [MAX_PATH];
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="keywordflow">if</span> (isalpha (directory[0]) &amp;&amp; (directory[1] == <span class="charliteral">&#39;:&#39;</span>))
<a name="l00336"></a>00336     nDrive = toupper (directory[0]) - <span class="charliteral">&#39;@&#39;</span>;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338     <span class="keywordflow">else</span>
<a name="l00339"></a>00339     {
<a name="l00340"></a>00340     GetCurrentDirectory (MAX_PATH, szCurDir);
<a name="l00341"></a>00341     nDrive = szCurDir[0] - <span class="charliteral">&#39;A&#39;</span> + 1;
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="comment">/* Set up the drive name */</span>
<a name="l00345"></a>00345 
<a name="l00346"></a>00346     strcpy (bName, <span class="stringliteral">&quot;x:\\&quot;</span>);
<a name="l00347"></a>00347     bName[0] = (char) (nDrive + <span class="charliteral">&#39;@&#39;</span>);
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 <span class="comment">/* Read the volume info, if we fail - assume non-HPFS */</span>
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     DISABLE_HARD_ERRORS;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353     rc = GetVolumeInformation (bName, (LPTSTR)NULL, 0, (LPDWORD)NULL,
<a name="l00354"></a>00354                    &amp;maxname, &amp;flags, (LPTSTR)NULL, 0);
<a name="l00355"></a>00355     ENABLE_HARD_ERRORS;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357     <span class="keywordflow">return</span> ((rc) &amp;&amp; (flags &amp; (FS_CASE_SENSITIVE | FS_CASE_IS_PRESERVED)))
<a name="l00358"></a>00358             ? <a class="code" href="odldef_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> : FALSE;
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
</pre></div></div>
</div>
<hr size="1"><address style="align: right;"><small>
<center>
MISR Toolkit - Copyright &copy 2005 - 2006 Jet Propulsion Laboratory<br>
Generated on Thu May 15 2014 10:14:16
</center></small></address>
</body>
</html>
